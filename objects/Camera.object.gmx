<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
 * Projection variables
 */

x=0;
y=0;
z=100;

xto=512;
yto=512;
zto=0;

xup=0;
yup=0;
zup=1;

fov=50;
pitch=0;

/*
 * Editor modes
 */

mode=EditorModes.EDITOR_3D;

enum EditorModes {
    EDITOR_3D,
    EDITOR_EVENT,
}

/*
 * Raycasting stuff
 */

MOUSE_X=window_mouse_get_x();
MOUSE_Y=window_mouse_get_y();

mouse_vector=array_compose(1, 1, 1);

/*
 * Vertex formats
 */

draw_set_alpha_test(true);

vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_normal();
vertex_format_add_textcoord();
vertex_format_add_colour();
vertex_format_add_colour();     // second color information is for extra data
vertex_format=vertex_format_end();

vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_colour();
vertex_format_line=vertex_format_end();

grid=noone;
graphics_create_grid();

/*
 * selection stuff
 */

under_cursor=noone;

selection=ds_list_create();
selected_entities=ds_list_create();
last_selection=noone;

selection_mode=SelectionModes.RECTANGLE;
selection_addition=false;

selection_fill_type=FillTypes.TILE;

selection_mask=SELECTION_MASK_ALL;          // only entities matching the mask will be processed

selection_fill_mesh=0;
selection_fill_tile_x=4;
selection_fill_tile_y=0;
selection_fill_autotile=0;

view_selection_mask=false;
view_wireframe=false;
view_grid=true;
view_backface=false;
view_texture=true;
view_entities=true; /* this sounds dumb */

tile_data_view=TileSelectorDisplayMode.PASSAGE;
tile_on_click=TileSelectorOnClick.SELECT;

enum TileSelectorDisplayMode {
    PASSAGE,
    PRIORITY,
    FLAGS,
    TAGS,
}

enum TileSelectorOnClick {
    SELECT,
    MODIFY,
}

/*
 * inputs; maybe these can be rebound though a menu, but that's not important now
 */

input_selection_add=vk_control;

/*
 * other stuff
 */

changes=ds_list_create();
ui=ui_init_main();
ui_event=ui_init_event();
menu=instance_create(0, 0, MenuMain);
dialogs=ds_list_create();

stuff_to_destroy=ds_queue_create();

instance_deactivate_object(UIThing);

texture_set_repeat(true);

/*
 * preview stuff
 */

mesh_preview=noone;
mesh_x=0;
mesh_y=0;
mesh_z=0;
mesh_xrot=0;
mesh_yrot=0;
mesh_zrot=0;
mesh_scale=1;

mesh_preview_grid=vertex_create_buffer();
vertex_begin(mesh_preview_grid, vertex_format_line);

var x1=-6*TILE_WIDTH;
var y1=-6*TILE_HEIGHT;
var x2=-x1;
var y2=-y1;
for (var i=0; i&lt;=12; i++){
    vertex_point_line(mesh_preview_grid, x1+i*TILE_WIDTH, y1, 0, c_white, 1);
    vertex_point_line(mesh_preview_grid, x1+i*TILE_WIDTH, y2, 0, c_white, 1);
    
    vertex_point_line(mesh_preview_grid, x1, y1+i*TILE_HEIGHT, 0, c_white, 1);
    vertex_point_line(mesh_preview_grid, x2, y1+i*TILE_HEIGHT, 0, c_white, 1);
}

vertex_end(mesh_preview_grid);
vertex_freeze(mesh_preview_grid);

/*
 * end of step actions
 */

schedule_rebuild_master_texture=false;
schedule_view_master_texture=false;
schedule_open=false;
//schedule_list_kill=ds_list_create();            // list of arrays of [list index, current index]

/*
 * enumerated constants that i need
 */

enum SelectionModes {
    SINGLE,
    RECTANGLE,
    CIRCLE
}

enum FillTypes {
    TILE,
    AUTOTILE,
    MESH,
    PAWN,
    EFFECT,
    EVENT,
}

fill_types=array_compose(safc_fill_tile, safc_fill_autotile, safc_fill_mesh, safc_fill_pawn, safc_fill_effect, safc_fill_event);

/*
 * the autotile shader
 */

shd_uniform_at_tex_offset=shader_get_uniform(shd_default_autotile, "texoffset");
shd_value_at_tex_offset=array_create(MAX_AUTOTILE_SHADER_POSITIONS);
//array_clear(shd_value_at_tex_offset, 2/(Stuff.tile_size/TEXTURE_SIZE))

/*
 * Event editor
 */

event_canvas_active_node=noone;
event_canvas_active_node_index=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Preliminary stuff

MOUSE_X=window_mouse_get_x();
MOUSE_Y=window_mouse_get_y();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// step cleanup actions
// dialogs (or other things) to be killed

while (!ds_queue_empty(stuff_to_destroy)){
    var thing=ds_queue_dequeue(stuff_to_destroy);
    instance_activate_object(thing);
    instance_destroy(thing);
}

// batch updates

var future=ActiveMap.batch_in_the_future;

var cindex=0;

// the list may still be appended to while it's being looped over - which is a
// TERRIBLE idea, but i don't have the time to come up with something that will
// appease the stackoverflow gods so too bad for them

//for (var i=0; i&lt;ds_list_size(changes); i++){
while (cindex&lt;ds_list_size(changes)){
    var thing=changes[| cindex++];
    switch (thing.modification){
        case Modifications.CREATE:
            instance_deactivate_object(thing);
            script_execute(thing.on_create, thing);
            thing.modification=Modifications.NONE;
            break;
        case Modifications.UPDATE:
            if (thing.batch_index==-1){
                debug("how did you even get here?");
            } else {
                batch_again(thing.batch_index);
            }
            script_execute(thing.on_update, thing);
            thing.modification=Modifications.NONE;
            break;
        case Modifications.REMOVE:
            map_remove_thing(thing);
            
            instance_activate_object(thing);
            instance_destroy(thing);
            
            // no point changing thing.modification now
            break;
    }
    // it turns out you can't put any mode code involving thing here because if it
    // was deleted it'll break things
}

ds_list_clear(changes);

// you may add/delete/move stuff in bulk and doing this for each
// entity that was changed would slow the editor down quite a lot
if (ds_list_size(ActiveMap.batch_in_the_future)&gt;BATCH_CACHE_SIZE){
    batch_cache();
}

// this is important, but gets turned back on when the 3D stuff gets dealt
// with in the next frame
d3d_end();
d3d_set_hidden(false);

var ts=get_active_tileset();

if (schedule_rebuild_master_texture){
    if (sprite_exists(ts.master)){
        sprite_delete(ts.master);
    }
    ts.master=tileset_create_master(ts);
    schedule_rebuild_master_texture=false;
}

if (schedule_view_master_texture){
    sprite_save_fixed(ts.master, 0, "master-preview.png");
    ds_stuff_open_local("master-preview.png");
    schedule_view_master_texture=false;
}

if (schedule_open){
    var fn=get_open_filename("DDD game files ("+EXPORT_EXTENSION_DATA+", "+EXPORT_EXTENSION_MAP+")|*"+EXPORT_EXTENSION_DATA+";*"+EXPORT_EXTENSION_MAP, "");
    
    if (file_exists(fn)){
        serialize_load(fn);
    }
    
    schedule_open=false;
}

/*for (var i=0; i&lt;ds_list_size(schedule_list_kill); i++){
    var data=schedule_list_kill[| i];
    var victim=data[@ 0];
    var current=data[@ 1];
    for (var j=current; j&lt;min(current+100, ds_list_size(victim)); j++){
        instance_activate_object(victim[| j]);
        instance_destroy(victim[| j]);
    }
    if (j==ds_list_size(victim)){
        ds_list_destroy(victim);
        ds_list_delete(schedule_list_kill, i--);
    }
}*/

// controller is invisible so

Controller.mouse_x_previous=mouse_x;
Controller.mouse_y_previous=mouse_y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Anything visible in the world

switch (mode){
    case EditorModes.EDITOR_3D:
        switch (view_current){
            case view_3d:
                draw_clear(c_black);
                draw_editor_3d();
                break;
            case view_ribbon:
                draw_editor_menu();
                break;
            case view_hud:
                draw_editor_hud();
                break;
            case view_3d_preview:
                // the pop-out window that isn't really a pop-out window
                draw_clear(c_black);
                draw_preview_3d();
                draw_preview_3d_overlay();
                break;
        }
        break;
    case EditorModes.EDITOR_EVENT:
        switch (view_current){
            case view_fullscreen:
                draw_editor_event();
                break;
            case view_ribbon:
                draw_editor_menu();
                break;
            case view_hud:
                draw_editor_event_hud();
                break;
        }
        break;
}

// these shouldn't be attached to any one view or anything
if (view_current=view_invisible){
    control_global();
}

/*
 * please don't touch these settings, or any of the other settings relating to
 * the room/views, unless you know what you're doing and are prepared for pain
 *
 * Views:
 *
 * 0. fullscreen
 * 1. 3D
 * 2. Ribbon
 * 3. HUD (side)
 * 4. 3D Preview
 */
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
