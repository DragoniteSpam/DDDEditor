<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
 * Projection variables
 */

x=0;
y=0;
z=100;

xto=512;
yto=512;
zto=0;

xup=0;
yup=0;
zup=1;

fov=50;
pitch=0;

/*
 * Raycasting stuff
 */

MOUSE_X=window_mouse_get_x();
MOUSE_Y=window_mouse_get_y();
WW=window_get_width();
HH=window_get_height();

mouse_vector=array_compose(1, 1, 1);

/*
 * Vertex formats
 */

vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_normal();
vertex_format_add_textcoord();
vertex_format_add_colour();
vertex_format=vertex_format_end();

vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_colour();
vertex_format_line=vertex_format_end();

grid=noone;
graphics_create_grid();

/*
 * selection stuff
 */

under_cursor=noone;

selection_start=selection_empty();
selection_end=selection_empty();

/*
 * enumerated constants that i need
 */

enum vec3 {
    xx,
    yy,
    zz
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move the camera

MOUSE_X=window_mouse_get_x();
MOUSE_Y=window_mouse_get_y();
WW=window_get_width();
HH=window_get_height();

var mspd=(min(log10(max(abs(z), 1))*4, 320)+1)/Stuff.dt;
var xspeed=0;
var yspeed=0;
var zspeed=0;

if (keyboard_check(vk_up)||keyboard_check(ord('W'))){
    xspeed=dcos(direction)*mspd*Stuff.dt;
    yspeed=-dsin(direction)*mspd*Stuff.dt;
    zspeed=-dsin(pitch)*mspd*Stuff.dt;
}
if (keyboard_check(vk_down)||keyboard_check(ord('S'))){
    xspeed=-dcos(direction)*mspd*Stuff.dt;
    yspeed=dsin(direction)*mspd*Stuff.dt;
    zspeed=dsin(pitch)*mspd*Stuff.dt;
}
if (keyboard_check(vk_left)||keyboard_check(ord('A'))){
    xspeed=-dsin(direction)*mspd*Stuff.dt;
    yspeed=-dcos(direction)*mspd*Stuff.dt;
}
if (keyboard_check(vk_right)||keyboard_check(ord('D'))){
    xspeed=dsin(direction)*mspd*Stuff.dt;
    yspeed=dcos(direction)*mspd*Stuff.dt;
}
if (mouse_check_button(mb_middle)){
    var dx=(MOUSE_X-WW/2)/16;
    var dy=(MOUSE_Y-HH/2)/16;
    direction=(360+direction-dx)%360;
    pitch=clamp(pitch+dy, -80, 80);
    window_mouse_set(WW/2, HH/2);
    xto=x+dcos(direction);
    yto=y-dsin(direction);
    zto=z-dsin(pitch);
}

x+=xspeed;
y+=yspeed;
z+=zspeed;
xto+=xspeed;
yto+=yspeed;
zto+=zspeed;
xup=0;
yup=0;
zup=1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Select stuff with the mouse

mouse_vector=update_mouse_vector(x, y, z, xto, yto, zto, xup, yup, zup, fov, W/H);

var xx=mouse_vector[vec3.xx]*MILLION;
var yy=mouse_vector[vec3.yy]*MILLION;
var zz=mouse_vector[vec3.zz]*MILLION;

if (c_raycast_world(x, y, z, x+xx, y+yy, z+zz, ~0)){
    under_cursor=c_object_get_userid(c_hit_object(0));
} else {
    under_cursor=noone;
}

var floor_x=-1;
var floor_y=-1;
var floor_cx=-1;
var floor_cy=-1;

if (zz&lt;z){
    var f=abs(z/zz);
    floor_x=x+xx*f;
    floor_y=y+yy*f;
    
    floor_cx=clamp(floor_x div Stuff.tile_width, 0, ActiveMap.xx);
    floor_cy=clamp(floor_y div Stuff.tile_height, 0, ActiveMap.yy);
    
    if (mouse_check_button_pressed(mb_left)){
        // Begin selection
        if (selection_start[vec3.zz]==-1){
            if (under_cursor==noone){
                selection_start[vec3.zz]=0;
                selection_end[vec3.zz]=0;
            } else {
                selection_start[vec3.zz]=under_cursor.zz;
                selection_end[vec3.zz]=under_cursor.zz;
            }
            selection_start[vec3.xx]=floor_cx;
            selection_start[vec3.yy]=floor_cy;
            selection_end[vec3.xx]=floor_cx;
            selection_end[vec3.yy]=floor_cy;
        // Clear selection
        } else {
            selection_start=selection_empty();
            selection_end=selection_empty();
        }
    }
    if (mouse_check_button(mb_left)){
        if (selection_start[vec3.zz]&gt;-1){
            selection_end[vec3.xx]=floor_cx;
            selection_end[vec3.yy]=floor_cy;
        }
    }
    if (mouse_check_button_released(mb_left)){
    }
}

if (keyboard_check_pressed(vk_space)){
    if (selection_start[vec3.zz]&gt;-1){
        var x1=min(selection_start[vec3.xx], selection_end[vec3.xx]);
        var y1=min(selection_start[vec3.yy], selection_end[vec3.yy]);
        var x2=max(selection_start[vec3.xx], selection_end[vec3.xx]);
        var y2=max(selection_start[vec3.yy], selection_end[vec3.yy]);
        for (var i=x1; i&lt;x2; i++){
            for (var j=y1; j&lt;y2; j++){
                map_add_thing(instance_create_tile(4, 0), i, j, 0);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Anything visible in the world

d3d_start();
d3d_set_culling(true);
d3d_set_hidden(true);

// todo GMS2 requires smooth shading to be handled by the shader(s) now,
// so to make porting this to GMS2 as pain-free as possible I'd like to
// do it that way here at some point in the future too

draw_set_color(c_white);

d3d_set_projection_ext(x, y, z,
    xto, yto, zto,
    xup, yup, zup,
    fov, W/H, 1, 32000);

// anything in the world

// this will need to be dynamic at some point
var tex=sprite_get_texture(b_tileset_overworld, 0);
for (var i=0; i&lt;ds_list_size(ActiveMap.batches); i++){
    vertex_submit(ActiveMap.batches[| i], pr_trianglelist, tex);
}
for (var i=0; i&lt;ds_list_size(ActiveMap.batch_in_the_future); i++){
    var ent=ActiveMap.batch_in_the_future[| i];
    script_execute(ent.render, ent);
}
for (var i=0; i&lt;ds_list_size(ActiveMap.dynamic); i++){
    var ent=ActiveMap.dynamic[| i];
    script_execute(ent.render, ent);
}

// the grid, which you may want an option to turn this off if it gets annoying
// also anything else that gets drawn independently of the z buffer
d3d_set_zwriteenable(false);
vertex_submit(grid, pr_linelist, -1);

d3d_set_culling(false);
if (selection_start[vec3.zz]&gt;-1){
    transform_set(0, 0, selection_start[vec3.zz]*Stuff.tile_depth, 0, 0, 0, 1, 1, 1);
    
    var x1=selection_start[vec3.xx]*Stuff.tile_width;
    var y1=selection_start[vec3.yy]*Stuff.tile_height;
    var x2=selection_end[vec3.xx]*Stuff.tile_width;
    var y2=selection_end[vec3.yy]*Stuff.tile_height;
    var w=12;
    
    draw_line_width_colour(x1, y1, x1, y2, w, c_red, c_red);
    draw_line_width_colour(x1, y1, x2, y1, w, c_red, c_red);
    draw_line_width_colour(x2, y1, x2, y2, w, c_red, c_red);
    draw_line_width_colour(x1, y2, x2, y2, w, c_red, c_red);
    transform_reset();
}
d3d_set_zwriteenable(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
